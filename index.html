<!DOCTYPE html>
<html lang="en" class="dark">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Save Data Calculator</title>
    <meta name="theme-color" content="#06b6d4" />
    <meta name="description" content="A calculator to determine the points for a save data configuration based on a complex set of rules including card types, states, duplications, removals, and conversions." />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        darkMode: 'class',
        theme: {
          extend: {
            fontFamily: {
              sans: ['Inter', 'sans-serif'],
            },
          },
        },
      }
    </script>
    <!-- React, ReactDOM, and Babel for in-browser JSX/TS transformation -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script type="importmap">
{
  "imports": {
    "vite-plugin-pwa": "https://aistudiocdn.com/vite-plugin-pwa@^1.1.0",
    "vite": "https://aistudiocdn.com/vite@^7.2.2",
    "@vitejs/plugin-react": "https://aistudiocdn.com/@vitejs/plugin-react@^5.1.1",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "react": "https://aistudiocdn.com/react@^19.2.0"
  }
}
</script>
<link rel="stylesheet" href="/index.css">
</head>
  <body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-white transition-colors duration-300">
    <div id="root"></div>
    <script type="text/babel">
      // --- From types.ts ---
      var CardType;
      (function (CardType) {
          CardType["BASIC"] = "basic";
          CardType["UNIQUE"] = "unique";
          CardType["NEUTRAL"] = "neutral";
          CardType["MONSTER"] = "monster";
          CardType["FORBIDDEN"] = "forbidden";
      })(CardType || (CardType = {}));
      var CardState;
      (function (CardState) {
          CardState["NONE"] = "none";
          CardState["EPIPHANY"] = "epiphany";
          CardState["DIVINE_EPIPHANY"] = "divine_epiphany";
      })(CardState || (CardState = {}));
      var CardEffect;
      (function (CardEffect) {
          CardEffect["UNIQUE"] = "unique";
          CardEffect["REMOVE"] = "remove";
      })(CardEffect || (CardEffect = {}));

      // --- From constants.ts ---
      const POINTS = {
          NEUTRAL_CARD: 20,
          UNIQUE_CARD: 80,
          MONSTER_CARD: 80,
          FORBIDDEN_CARD: 20,
          EPIPHANY_BONUS: 10,
          DIVINE_EPIPHANY_BONUS: 20,
          CONVERSION_COST: 10,
          BASIC_REMOVAL_BONUS: 20,
      };
      const REMOVAL_COST_LADDER = [0, 10, 30, 50, 70];
      const DUPLICATION_COST_LADDER = [0, 10, 30, 50, 70];

      // --- From components/Icons.tsx ---
      const PlusIcon = ({ className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
          strokeWidth={1.5}
          stroke="currentColor"
          className={className}
        >
          <path strokeLinecap="round" strokeLinejoin="round" d="M12 4.5v15m7.5-7.5h-15" />
        </svg>
      );
      const UndoIcon = ({ className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}>
          <path fillRule="evenodd" d="M9.53 2.47a.75.75 0 0 1 0 1.06L4.81 8.25H15a6.75 6.75 0 0 1 0 13.5h-3a.75.75 0 0 1 0-1.5h3a5.25 5.25 0 1 0 0-10.5H4.81l4.72 4.72a.75.75 0 1 1-1.06 1.06l-6-6a.75.75 0 0 1 0-1.06l6-6a.75.75 0 0 1 1.06 0Z" clipRule="evenodd" />
        </svg>
      );
      const ResetIcon = ({ className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className={className}>
          <path fillRule="evenodd" d="M15.323 4.677a.75.75 0 0 0-1.06-1.06l-1.061 1.06a5.5 5.5 0 1 0 5.484 6.222.75.75 0 1 0-1.488-.223A4 4 0 1 1 13.5 7.018l-1.06 1.06a.75.75 0 0 0 0 1.061.75.75 0 0 0 1.06 0l2.83-2.828a.75.75 0 0 0 0-1.06l-2.83-2.83Z" clipRule="evenodd" />
        </svg>
      );
      const ThemeIcon = ({ theme, className }) => (
        <>
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={`${className} ${theme === 'dark' ? 'block' : 'hidden'}`}>
            <path strokeLinecap="round" strokeLinejoin="round" d="M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-4.773-4.227-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0Z" />
          </svg>
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={`${className} ${theme === 'light' ? 'block' : 'hidden'}`}>
            <path strokeLinecap="round" strokeLinejoin="round" d="M21.752 15.002A9.72 9.72 0 0 1 18 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 0 0 3 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 0 0 9.002-5.998Z" />
          </svg>
        </>
      );
      const EpiphanyIcon = ({ className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className={className}>
          <path d="M10 7a3 3 0 1 0 0 6 3 3 0 0 0 0-6Z" />
          <path fillRule="evenodd" d="M10 18a8 8 0 1 0 0-16 8 8 0 0 0 0 16Zm0-2a6 6 0 1 0 0-12 6 6 0 0 0 0 12Z" clipRule="evenodd" />
        </svg>
      );
      const DivineEpiphanyIcon = ({ className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className={className}>
          <path d="m10 0 2.89 7.11 7.11 2.89-7.11 2.89L10 20l-2.89-7.11-7.11-2.89 7.11-2.89L10 0Z" />
        </svg>
      );
      const ArrowPathIcon = ({ className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className={className}>
          <path fillRule="evenodd" d="M15.312 11.424a5.5 5.5 0 0 1-9.201 2.466l-.312-.311h2.433a.75.75 0 0 0 0-1.5H3.989a.75.75 0 0 0-.75.75v4.242a.75.75 0 0 0 1.5 0v-2.43l.31.31a7 7 0 0 0 11.767-3.131.75.75 0 0 0-1.488-.214ZM4.688 8.576a5.5 5.5 0 0 1 9.201-2.466l.312.311H11.76a.75.75 0 0 0 0 1.5h4.243a.75.75 0 0 0 .75-.75V3.029a.75.75 0 0 0-1.5 0v2.43l-.31-.31a7 7 0 0 0-11.767 3.131.75.75 0 0 0 1.488.214Z" clipRule="evenodd" />
        </svg>
      );
      const Square2StackIcon = ({ className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className={className}>
          <path d="M7 3.5A1.5 1.5 0 0 1 8.5 2h6A1.5 1.5 0 0 1 16 3.5v9a1.5 1.5 0 0 1-1.5 1.5h-2.5a.75.75 0 0 1 0-1.5h2.5a.5.5 0 0 0 .5-.5v-9a.5.5 0 0 0-.5-.5h-6a.5.5 0 0 0-.5.5v2.5a.75.75 0 0 1-1.5 0v-2.5Z" />
          <path d="M3.5 6A1.5 1.5 0 0 0 2 7.5v9A1.5 1.5 0 0 0 3.5 18h6a1.5 1.5 0 0 0 1.5-1.5v-9A1.5 1.5 0 0 0 9.5 6h-6Z" />
        </svg>
      );
      const MinusCircleIcon = ({ className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className={className}>
          <path fillRule="evenodd" d="M10 18a8 8 0 1 0 0-16 8 8 0 0 0 0 16ZM6.75 9.25a.75.75 0 0 0 0 1.5h6.5a.75.75 0 0 0 0-1.5h-6.5Z" clipRule="evenodd" />
        </svg>
      );
      const GitHubIcon = ({ className }) => (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 16 16"
          fill="currentColor"
          className={className}
          aria-hidden="true"
        >
          <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8Z" />
        </svg>
      );
      const XIcon = ({ className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className={className}>
          <path fillRule="evenodd" d="M10 18a8 8 0 1 0 0-16 8 8 0 0 0 0 16ZM8.28 7.22a.75.75 0 0 0-1.06 1.06L8.94 10l-1.72 1.72a.75.75 0 1 0 1.06 1.06L10 11.06l1.72 1.72a.75.75 0 1 0 1.06-1.06L11.06 10l1.72-1.72a.75.75 0 0 0-1.06-1.06L10 8.94 8.28 7.22Z" clipRule="evenodd" />
        </svg>
      );

      // --- From database.ts ---
      const generateDummyImage = (text, bgColor = '#4A5568', textColor = '#FFFFFF') => {
          const svg = `
              <svg xmlns="http://www.w3.org/2000/svg" width="200" height="240" viewBox="0 0 200 240">
                  <rect width="100%" height="100%" fill="${bgColor}" />
              </svg>
          `.trim();
          return `data:image/svg+xml;base64,${btoa(svg)}`;
      };
      const nameToImagePath = (name) => {
          const fileName = name.toLowerCase().replace(/ /g, '-');
          return `./cards/${fileName}.png`;
      };
      const cardImageColors = {
          [CardType.BASIC]: '#718096',
          [CardType.UNIQUE]: '#3182CE',
          [CardType.NEUTRAL]: '#A0AEC0',
          [CardType.MONSTER]: '#6B46C1',
          [CardType.FORBIDDEN]: '#E53E3E',
      };
      const createCard = (id, type, name, options = {}) => ({
          id,
          type,
          name,
          originalType: type,
          state: CardState.NONE,
          ...options,
      });
      const createDeckFromData = (data) => {
          return data.map(cardData => {
              const isUltimate = !!cardData.isUltimate;
              const color = isUltimate ? '#805AD5' : cardImageColors[cardData.type];
              const imageUrl = cardData.imageUrl || generateDummyImage(cardData.name, color);
              return createCard(cardData.id, cardData.type, cardData.name, {
                  isUltimate: cardData.isUltimate,
                  effects: cardData.effects,
                  imageUrl,
              });
          });
      };
      const DEFAULT_DECK_DATA = [
          { id: 1, type: CardType.BASIC, name: 'Basic Card' },
          { id: 2, type: CardType.BASIC, name: 'Basic Card' },
          { id: 3, type: CardType.BASIC, name: 'Basic Card' },
          { id: 4, type: CardType.UNIQUE, name: 'Unique Card' },
          { id: 5, type: CardType.UNIQUE, name: 'Unique Card' },
          { id: 6, type: CardType.UNIQUE, name: 'Unique Card' },
          { id: 7, type: CardType.UNIQUE, name: 'Unique Card' },
          { id: 8, type: CardType.UNIQUE, name: 'Ultimate Card', isUltimate: true },
      ];
      const MIKA_DECK_DATA = [
          { id: 1, type: CardType.BASIC, name: 'Water Arrow', imageUrl: './cards/mika-1.png' },
          { id: 2, type: CardType.BASIC, name: 'Water Barrier', imageUrl: './cards/mika-3.png' },
          { id: 3, type: CardType.BASIC, name: 'Water Barrier', imageUrl: './cards/mika-3.png' },
          { id: 4, type: CardType.UNIQUE, name: 'Source of Water', imageUrl: './cards/mika-4.png' },
          { id: 5, type: CardType.UNIQUE, name: 'Blessing of Waves', imageUrl: './cards/mika-5.png' },
          { id: 6, type: CardType.UNIQUE, name: 'Tactical Analysis', imageUrl: './cards/mika-6.png' },
          { id: 7, type: CardType.UNIQUE, name: 'Whirlpool', imageUrl: './cards/mika-7.png' },
          { id: 8, type: CardType.UNIQUE, name: 'Deluge', isUltimate: true, imageUrl: './cards/mika-8.png' },
      ];
      const HARU_DECK_DATA = [
          { id: 1, type: CardType.BASIC, name: 'Anchor', imageUrl: './cards/haru-1.png' },
          { id: 2, type: CardType.BASIC, name: 'Power Anchor', imageUrl: './cards/haru-2.png' },
          { id: 3, type: CardType.BASIC, name: 'Anchor Drop', imageUrl: './cards/haru-3.png' },
          { id: 4, type: CardType.UNIQUE, name: 'Anchor Shot', imageUrl: './cards/haru-4.png' },
          { id: 5, type: CardType.UNIQUE, name: 'Anchor Pointer', imageUrl: './cards/haru-5.png' },
          { id: 6, type: CardType.UNIQUE, name: 'Power Charge', imageUrl: './cards/haru-6.png' },
          { id: 7, type: CardType.UNIQUE, name: 'Charge Energy', imageUrl: './cards/haru-7.png' },
          { id: 8, type: CardType.UNIQUE, name: 'Lift Anchor', isUltimate: true, imageUrl: './cards/haru-8.png' },
      ];
      const RENOA_DECK_DATA = [
          { id: 1, type: CardType.BASIC, name: 'Annihilation Shot', imageUrl: './cards/renoa-1.png' },
          { id: 2, type: CardType.BASIC, name: 'Annihilation Shot', imageUrl: './cards/renoa-1.png' },
          { id: 3, type: CardType.BASIC, name: 'Black Veil', imageUrl: './cards/renoa-3.png' },
          { id: 4, type: CardType.UNIQUE, name: 'Echo of Sorrow', imageUrl: './cards/renoa-4.png' },
          { id: 5, type: CardType.UNIQUE, name: 'Instant Judgment', imageUrl: './cards/renoa-5.png' },
          { id: 6, type: CardType.UNIQUE, name: 'Ballad of Pitch Black', imageUrl: './cards/renoa-6.png' },
          { id: 7, type: CardType.UNIQUE, name: 'Flower of Devoured Fate', imageUrl: './cards/renoa-7.png' },
          { id: 8, type: CardType.UNIQUE, name: 'Last-Ditch Assault', isUltimate: true, imageUrl: './cards/renoa-8.png' },
      ];
      const VERONIA_DECK_DATA = [
          { id: 1, type: CardType.BASIC, name: 'Rapid Fire' imageUrl: './cards/veronica-1.png' },
          { id: 2, type: CardType.BASIC, name: 'Rapid Fire', imageUrl: './cards/veronica-1.png' },
          { id: 3, type: CardType.BASIC, name: 'Illusion of Golden Daffodils', imageUrl: './cards/veronica-3.png' },
          { id: 4, type: CardType.UNIQUE, name: 'Firing Preparation', imageUrl: './cards/veronica-4.png' },
          { id: 5, type: CardType.UNIQUE, name: 'Repose', imageUrl: './cards/veronica-5.png' },
          { id: 6, type: CardType.UNIQUE, name: 'Pendant of Resolution', imageUrl: './cards/veronica-6.png' },
          { id: 7, type: CardType.UNIQUE, name: 'Sir Kowalski', imageUrl: './cards/veronica-7.png' },
          { id: 8, type: CardType.UNIQUE, name: 'Bombardment Prep', isUltimate: true, imageUrl: './cards/veronica-8.png' },
      ];
      const DEFAULT_DECK = createDeckFromData(DEFAULT_DECK_DATA);
      const MIKA_DECK = createDeckFromData(MIKA_DECK_DATA);
      const HARU_DECK = createDeckFromData(HARU_DECK_DATA);
      const COMBATANTS = [
          { id: 'default', name: 'Default', deck: DEFAULT_DECK },
          { id: 'mika', name: 'Mika', deck: MIKA_DECK },
          { id: 'haru', name: 'Haru', deck: HARU_DECK },
      ];
      
      // --- From state.ts ---
      const getInitialGameState = (initialCards = DEFAULT_DECK) => ({
        cards: JSON.parse(JSON.stringify(initialCards)),
        removedCards: [],
        duplicationCount: 0,
        conversionCount: 0,
        nextId: Math.max(...initialCards.map(c => c.id)) + 1,
        actionLog: [],
        nextLogId: 1,
      });
      function getLadderCost(ladder, count) {
        const index = Math.min(count, ladder.length - 1);
        return ladder[index];
      }

      // --- From components/ScoreDisplay.tsx ---
      const Indicator = ({ label, isUsed }) => (
        <div className="flex items-center gap-2 text-sm font-medium bg-gray-200 dark:bg-gray-700 px-3 py-1.5 rounded-md">
          <span className="text-gray-800 dark:text-gray-300">{label}:</span>
          <span className={`font-bold ${isUsed ? 'text-red-500' : 'text-green-500 dark:text-green-400'}`}>
            {isUsed ? 'Used' : 'Available'}
          </span>
        </div>
      );
      const ScoreDisplay = ({ score, scoreLimit, onReset, onUndo, isUndoDisabled, isResetDisabled, isFreeRemoveUsed, isFreeDuplicateUsed }) => {
        const progressPercentage = Math.min((score / scoreLimit) * 100, 100);
        const isOverLimit = score > scoreLimit;
        return (
          <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md dark:shadow-lg p-4 border border-gray-200 dark:border-gray-700">
            <div className="w-full flex-grow">
              <div 
                className="relative h-8 w-full bg-gray-200 dark:bg-gray-700 rounded-full overflow-hidden border border-gray-300 dark:border-gray-600"
                role="progressbar"
                aria-valuenow={score}
                aria-valuemin={0}
                aria-valuemax={scoreLimit}
                aria-label={`Score: ${score} out of ${scoreLimit}`}
              >
                <div 
                  className={`absolute top-0 left-0 h-full rounded-full transition-all duration-300 ${isOverLimit ? 'bg-red-500' : 'bg-cyan-500'}`}
                  style={{ width: `${isOverLimit ? 100 : progressPercentage}%` }}
                ></div>
                <div className="absolute inset-0 flex items-center justify-center" aria-hidden="true">
                  <span className="text-sm font-mono font-bold text-gray-900 dark:text-white tracking-wider">
                    {score} / {scoreLimit}
                  </span>
                </div>
              </div>
            </div>
            <div className="mt-4 flex justify-between items-center">
              <div className="flex items-center gap-3">
                <Indicator label="Free Remove" isUsed={isFreeRemoveUsed} />
                <Indicator label="Free Duplicate" isUsed={isFreeDuplicateUsed} />
              </div>
              <div className="flex items-center gap-2">
                <button
                  onClick={onUndo}
                  disabled={isUndoDisabled}
                  className="px-3 py-2 bg-yellow-500 text-black font-semibold rounded-md flex items-center gap-2 transition-opacity duration-200 disabled:opacity-50 hover:enabled:bg-yellow-400"
                  aria-label="Undo last action"
                >
                  <UndoIcon className="h-5 w-5" />
                  <span className="hidden sm:inline">Undo</span>
                </button>
                <button
                  onClick={onReset}
                  disabled={isResetDisabled}
                  className="px-3 py-2 bg-red-600 text-white font-semibold rounded-md flex items-center gap-2 transition-opacity duration-200 disabled:opacity-50 hover:enabled:bg-red-500"
                  aria-label="Reset calculator"
                >
                  <ResetIcon className="h-5 w-5" />
                  <span className="hidden sm:inline">Reset</span>
                </button>
              </div>
            </div>
          </div>
        );
      };
      
      // --- From components/CalculatorCard.tsx ---
      const cardStyles = {
        base: 'aspect-[2/3] w-full max-w-[280px] mx-auto rounded-lg shadow-lg p-3 flex flex-col justify-between transition-all duration-300 border-2 relative',
        [CardType.BASIC]: 'bg-gray-200 border-gray-300 text-gray-800 dark:bg-gray-700 dark:border-gray-600 dark:text-white',
        [CardType.UNIQUE]: 'bg-blue-200 border-blue-400 text-blue-900 dark:bg-blue-900/50 dark:border-blue-700 dark:text-white',
        [CardType.NEUTRAL]: 'bg-stone-300 border-stone-400 text-stone-900 dark:bg-stone-600 dark:border-stone-500 dark:text-white',
        [CardType.MONSTER]: 'bg-gradient-to-br from-purple-400 to-blue-400 border-purple-500 text-white dark:from-purple-800 dark:to-blue-800 dark:border-purple-600',
        [CardType.FORBIDDEN]: 'bg-red-200 border-red-400 text-red-900 dark:bg-red-900/50 dark:border-red-700 dark:text-white',
        ULTIMATE: 'bg-purple-200 border-purple-400 text-purple-900 dark:bg-purple-900/50 dark:border-purple-700 dark:text-white',
      };
      const stateStyles = {
        [CardState.NONE]: 'border-opacity-50',
        [CardState.EPIPHANY]: 'border-yellow-500 dark:border-yellow-400 shadow-yellow-500/40 dark:shadow-yellow-400/30 shadow-[0_0_15px]',
        [CardState.DIVINE_EPIPHANY]: 'border-cyan-500 dark:border-cyan-400 shadow-cyan-500/40 dark:shadow-cyan-400/30 shadow-[0_0_15px]',
      };
      const buttonStyles = {
        base: 'font-semibold py-1.5 rounded-md transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-900 flex items-center justify-center gap-1.5',
        enabled: 'hover:bg-opacity-80',
        disabled: 'opacity-50 cursor-not-allowed',
      };
      const ActionButton = ({ onClick, label, color, disabled = false, icon, textSize, className, showLabel }) => (
        <button
          onClick={onClick}
          disabled={disabled}
          style={{ fontSize: `${textSize}px` }}
          className={`${buttonStyles.base} ${color} ${
            disabled ? buttonStyles.disabled : buttonStyles.enabled
          } ${showLabel ? 'px-2' : 'px-1.5'} ${className || ''}`}
        >
          {icon}
          {showLabel && <span className="min-w-0 truncate">{label}</span>}
        </button>
      );
      const CalculatorCard = ({ card, isLast, onUpdate, onRemove, onDuplicate, onConvert, onDiscard, buttonTextSize, combatantCount }) => {
        const showLabel = combatantCount === 1;
        const isEpiphanyDisabled = card.type === CardType.BASIC || isLast;
        const isDuplicatable = card.type !== CardType.BASIC && !card.effects?.includes(CardEffect.UNIQUE);
        const isStateLocked = card.state === CardState.EPIPHANY || card.state === CardState.DIVINE_EPIPHANY;
        const handleStateChange = (newState) => {
          if (isStateLocked) {
            return;
          }
          onUpdate({
            ...card,
            state: newState,
          });
        };
        const handleConvert = () => {
          onConvert(card.id);
        };
        const cardTitle = card.name || (isLast ? 'Ultimate' : card.type);
        const actionButtons = [];
        actionButtons.push(
          <ActionButton 
            key="convert"
            label="Convert"
            color="bg-gray-300 text-black"
            onClick={handleConvert}
            disabled={card.type === CardType.NEUTRAL}
            icon={<ArrowPathIcon className="w-4 h-4 flex-shrink-0" />}
            textSize={buttonTextSize}
            showLabel={showLabel}
          />
        );
        if (isDuplicatable) {
          actionButtons.push(
            <ActionButton 
              key="duplicate"
              label="Duplicate"
              color="bg-purple-600 text-white"
              onClick={() => onDuplicate(card)}
              icon={<Square2StackIcon className="w-4 h-4 flex-shrink-0" />}
              textSize={buttonTextSize}
              showLabel={showLabel}
            />
          );
        }
        actionButtons.push(
          <ActionButton 
            key="remove"
            label="Remove"
            color="bg-red-600 text-white"
            onClick={() => onRemove(card.id)}
            icon={<MinusCircleIcon className="w-4 h-4 flex-shrink-0" />}
            textSize={buttonTextSize}
            showLabel={showLabel}
          />
        );
        const hasImage = !!card.imageUrl;
        const backgroundStyle = hasImage ? {
            backgroundImage: `url(${card.imageUrl})`,
            backgroundSize: 'cover',
            backgroundPosition: 'center',
        } : {};
        const titleColorStylesWithImage = {
          [CardType.BASIC]: 'text-white',
          [CardType.UNIQUE]: 'text-sky-300',
          [CardType.NEUTRAL]: 'text-stone-300',
          [CardType.MONSTER]: 'text-rose-500',
          [CardType.FORBIDDEN]: 'text-red-500',
          ULTIMATE: 'text-fuchsia-400',
        };
        const getTitleClassName = () => {
          if (!hasImage) {
            return '';
          }
          const colorClass = isLast ? titleColorStylesWithImage.ULTIMATE : titleColorStylesWithImage[card.type];
          return `${colorClass}`;
        };
        return (
          <div 
            className={`${cardStyles.base} ${isLast ? cardStyles.ULTIMATE : cardStyles[card.type]} ${stateStyles[card.state]}`}
            style={backgroundStyle}
          >
            {hasImage && (
              <div className="absolute inset-0 bg-[linear-gradient(to_bottom,rgba(0,0,0,0.8)_0%,transparent_15%,transparent_50%,rgba(0,0,0,0.9)_100%)] rounded-lg"></div>
            )}
            {card.type === CardType.NEUTRAL && (
              <div className="group absolute top-2 right-2 z-20">
                <button
                  onClick={() => onDiscard(card.id)}
                  className="p-0.5 bg-gray-600/50 hover:bg-red-600 rounded-full text-white transition-colors"
                  aria-label="Discard Neutral Card"
                >
                  <XIcon className="w-4 h-4" />
                </button>
                <div className="absolute right-full top-1/2 -translate-y-1/2 mr-2 w-max max-w-xs p-2 text-xs text-white bg-gray-900/90 dark:bg-black/90 rounded-md shadow-lg opacity-0 group-hover:opacity-100 pointer-events-none">
                  Only click this if Neutral card has [Remove] effect
                </div>
              </div>
            )}
            <div className="relative z-10 flex flex-col justify-between h-full">
              <div className="text-center min-h-[3rem]">
                <p className={`font-bold text-sm sm:text-base ${getTitleClassName()}`}>
                  {cardTitle}
                </p>
                <p className={`text-xs capitalize ${
                  card.state === CardState.NONE
                    ? (hasImage ? 'text-white/90' : 'opacity-50')
                    : (hasImage ? 'text-white font-semibold' : '')
                }`}>
                  {card.state.replace('_', ' ')}
                </p>
              </div>
              <div className="flex-grow my-2 flex items-center justify-center min-h-0">
              </div>
              <div className="flex flex-col gap-1.5">
                {!isEpiphanyDisabled && (
                  <div className="grid grid-cols-2 gap-1.5">
                    <ActionButton 
                      label="Epiphany"
                      color="bg-yellow-500 text-black"
                      onClick={() => handleStateChange(CardState.EPIPHANY)}
                      icon={<EpiphanyIcon className="w-4 h-4 flex-shrink-0" />}
                      textSize={buttonTextSize}
                      disabled={isStateLocked}
                      showLabel={showLabel}
                    />
                    <ActionButton 
                      label="Divine"
                      color="bg-cyan-500 text-black"
                      onClick={() => handleStateChange(CardState.DIVINE_EPIPHANY)}
                      icon={<DivineEpiphanyIcon className="w-4 h-4 flex-shrink-0" />}
                      textSize={buttonTextSize}
                      disabled={isStateLocked}
                      showLabel={showLabel}
                    />
                  </div>
                )}
                <div className="grid grid-cols-2 gap-1.5">
                  {actionButtons.map((button, index) => {
                    if (actionButtons.length % 2 !== 0 && index === actionButtons.length - 1) {
                      return React.cloneElement(button, { className: 'col-span-2' });
                    }
                    return button;
                  })}
                </div>
              </div>
            </div>
          </div>
        );
      };

      // --- From components/CombatantLayout.tsx ---
      const calculateTotalScore = (state, initialCardIds) => {
        const { cards, removedCards, duplicationCount, conversionCount } = state;
        let score = 0;
        cards.forEach(card => {
          const isNewlyAdded = !initialCardIds.has(card.id) && !card.isDuplicate;
          const isConvertedToNeutral = card.type === CardType.NEUTRAL && card.originalType !== CardType.NEUTRAL;
          if (isNewlyAdded) {
            if (card.type === CardType.UNIQUE) score += POINTS.UNIQUE_CARD;
            else if (card.type === CardType.MONSTER) score += POINTS.MONSTER_CARD;
            else if (card.type === CardType.NEUTRAL) score += POINTS.NEUTRAL_CARD;
            else if (card.type === CardType.FORBIDDEN) score += POINTS.FORBIDDEN_CARD;
          } else if (isConvertedToNeutral) {
            score += POINTS.NEUTRAL_CARD;
          }
          if (card.type !== CardType.BASIC) {
            if (card.state === CardState.EPIPHANY && card.type !== CardType.UNIQUE) {
              score += POINTS.EPIPHANY_BONUS;
            } else if (card.state === CardState.DIVINE_EPIPHANY) {
              score += POINTS.DIVINE_EPIPHANY_BONUS;
            }
          }
        });
        score += conversionCount * POINTS.CONVERSION_COST;
        let totalDuplicationCost = 0;
        for (let i = 0; i < duplicationCount; i++) {
          totalDuplicationCost += getLadderCost(DUPLICATION_COST_LADDER, i);
        }
        score += totalDuplicationCost;
        let totalRemovalCost = 0;
        removedCards.forEach((card, index) => {
          totalRemovalCost += getLadderCost(REMOVAL_COST_LADDER, index);
          if (card.originalType === CardType.BASIC && card.type === CardType.BASIC) {
            score += POINTS.BASIC_REMOVAL_BONUS;
          }
        });
        score += totalRemovalCost;
        return score;
      }
      const CombatantLayout = ({ combatantIndex, history, onHistoryChange, scoreLimit, combatantCount, buttonTextSize, combatants, selectedCombatantId, onCharacterChange }) => {
        const currentGameState = history[history.length - 1];
        const { cards, removedCards, duplicationCount, actionLog } = currentGameState;
        const initialCardIds = React.useMemo(() => new Set(history[0].cards.map(c => c.id)), [history[0]]);
        const handleReset = () => {
          const selectedCombatant = combatants.find(c => c.id === selectedCombatantId);
          onHistoryChange([getInitialGameState(selectedCombatant?.deck)]);
        };
        const handleUndo = () => {
          if (history.length > 1) {
            onHistoryChange(history.slice(0, -1));
          }
        };
        const updateGameStateAndLog = (updater, description, overridePoints) => {
          const oldState = history[history.length - 1];
          const oldScore = calculateTotalScore(oldState, initialCardIds);
          const changes = updater(oldState);
          const tempNewState = { ...oldState, ...changes };
          const newScore = calculateTotalScore(tempNewState, initialCardIds);
          const pointChange = overridePoints !== undefined ? overridePoints : newScore - oldScore;
          const newLogEntry = {
              id: oldState.nextLogId,
              description: description,
              points: pointChange,
          };
          const finalState = {
              ...tempNewState,
              actionLog: [...oldState.actionLog, newLogEntry],
              nextLogId: oldState.nextLogId + 1,
          }
          onHistoryChange([...history, finalState]);
        }
        const capitalize = (s) => s.charAt(0).toUpperCase() + s.slice(1);
        const formatStateName = (s) => s.replace(/_/g, ' ').split(' ').map(capitalize).join(' ');
        const getCardBaseName = (card) => {
          if (card.name) return card.name;
          return `${card.isUltimate ? 'Ultimate' : capitalize(card.type)} Card`;
        };
        const formatCardName = (card) => {
            const baseName = getCardBaseName(card);
            if (card.state !== CardState.NONE) {
                return `${formatStateName(card.state)} ${baseName}`;
            }
            return baseName;
        };
        const handleAddCard = (type) => {
          const updater = (current) => {
            const newCard = {
              id: current.nextId,
              type: type,
              originalType: type,
              state: CardState.NONE,
              name: `${capitalize(type)} Card`
            };
            return {
              cards: [...current.cards, newCard],
              nextId: current.nextId + 1,
            };
          }
          const description = `add ${capitalize(type)} Card`;
          updateGameStateAndLog(updater, description);
        };
        const handleUpdateCard = (updatedCard) => {
          const oldState = history[history.length - 1];
          const oldCard = oldState.cards.find(c => c.id === updatedCard.id);
          if (!oldCard) return;
          const updater = (current) => ({
            cards: current.cards.map(card => (card.id === updatedCard.id ? updatedCard : card)),
          });
          let description = `update ${formatCardName(oldCard)}`;
          if (oldCard.state !== updatedCard.state) {
              const cardBaseName = getCardBaseName(oldCard);
              if (updatedCard.state === CardState.NONE) {
                  description = `remove ${formatStateName(oldCard.state)} from ${cardBaseName}`;
              } else if (oldCard.state === CardState.NONE) {
                  description = `${formatStateName(updatedCard.state)} to ${cardBaseName}`;
              } else {
                  description = `convert ${cardBaseName} to ${formatStateName(updatedCard.state)}`;
              }
          }
          updateGameStateAndLog(updater, description);
        };
        const handleConvertCard = (cardId) => {
          const oldState = history[history.length - 1];
          const cardToConvert = oldState.cards.find(c => c.id === cardId);
          if (!cardToConvert) return;
          const updater = (current) => ({
            cards: current.cards.map(card =>
              card.id === cardId ? { ...card, type: CardType.NEUTRAL, state: CardState.NONE, name: 'Neutral Card' } : card
            ),
            conversionCount: current.conversionCount + 1,
          });
          const description = `convert ${formatCardName(cardToConvert)} to Neutral`;
          updateGameStateAndLog(updater, description);
        };
        const handleRemoveCard = (cardId) => {
          const oldState = history[history.length - 1];
          const cardToRemove = oldState.cards.find(card => card.id === cardId);
          if (!cardToRemove) return;
          const updater = (current) => ({
            cards: current.cards.filter(card => card.id !== cardId),
            removedCards: [...current.removedCards, cardToRemove],
          });
          const description = `remove ${formatCardName(cardToRemove)}`;
          updateGameStateAndLog(updater, description);
        };
        const handleDiscardCard = (cardId) => {
          const oldState = history[history.length - 1];
          const cardToDiscard = oldState.cards.find(c => c.id === cardId);
          if (!cardToDiscard || cardToDiscard.type !== CardType.NEUTRAL) return;
          const updater = (current) => ({
              cards: current.cards.filter(card => card.id !== cardId),
          });
          updateGameStateAndLog(updater, 'remove Neutral Card by [Remove] effect', 0);
        };
        const handleDuplicateCard = (cardToDuplicate) => {
          const updater = (current) => {
            const newCard = {
              ...cardToDuplicate,
              id: current.nextId,
              state: CardState.NONE, 
              isUltimate: false,
              isDuplicate: true,
            };
            return {
              cards: [...current.cards, newCard],
              duplicationCount: current.duplicationCount + 1,
              nextId: current.nextId + 1,
            };
          }
          const description = `duplicate ${formatCardName(cardToDuplicate)}`;
          updateGameStateAndLog(updater, description);
        };
        const totalScore = React.useMemo(() => {
          return calculateTotalScore(currentGameState, initialCardIds);
        }, [currentGameState, initialCardIds]);
        const cardGridClasses = combatantCount === 3
          ? 'grid-cols-4'
          : 'grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6';
        return (
          <div className="flex flex-col gap-4 bg-gray-100 dark:bg-gray-900/50 p-4 rounded-xl border border-gray-200 dark:border-gray-700">
            <div className="flex items-center justify-center gap-2">
              <label htmlFor={`combatant-character-select-${combatantIndex}`} className="text-lg font-bold">
                Combatant {combatantIndex + 1}:
              </label>
              <select
                id={`combatant-character-select-${combatantIndex}`}
                value={selectedCombatantId}
                onChange={(e) => onCharacterChange(combatantIndex, e.target.value)}
                className="bg-gray-200 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 text-lg font-bold rounded-lg focus:ring-cyan-500 focus:border-cyan-500 block w-auto p-1.5"
              >
                {combatants.map(c => (
                  <option key={c.id} value={c.id}>{c.name}</option>
                ))}
              </select>
            </div>
            <ScoreDisplay
              score={totalScore}
              scoreLimit={scoreLimit}
              onReset={handleReset}
              onUndo={handleUndo}
              isUndoDisabled={history.length <= 1}
              isResetDisabled={history.length <= 1}
              isFreeRemoveUsed={removedCards.length > 0}
              isFreeDuplicateUsed={duplicationCount > 0}
            />
            <div className={combatantCount === 1 ? "lg:grid lg:grid-cols-[minmax(0,_2fr)_minmax(0,_1fr)] gap-4" : "contents"}>
              <div className={`grid ${cardGridClasses} gap-4`}>
                {cards.map((card) => (
                  <CalculatorCard
                    key={card.id}
                    card={card}
                    isLast={!!card.isUltimate}
                    onUpdate={handleUpdateCard}
                    onRemove={handleRemoveCard}
                    onDuplicate={handleDuplicateCard}
                    onConvert={handleConvertCard}
                    onDiscard={handleDiscardCard}
                    buttonTextSize={buttonTextSize}
                    combatantCount={combatantCount}
                  />
                ))}
                <div className="aspect-[2/3] w-full max-w-[280px] mx-auto rounded-lg border-2 border-dashed border-gray-400 dark:border-gray-600 flex flex-col items-center justify-center p-3 gap-2">
                  <button
                    onClick={() => handleAddCard(CardType.NEUTRAL)}
                    className="w-full text-center text-sm font-semibold py-2 px-3 rounded-md transition-colors duration-200 bg-stone-500 text-white hover:bg-stone-600 dark:bg-stone-600 dark:hover:bg-stone-500"
                    aria-label="Add new neutral card"
                  >
                    Add Neutral
                  </button>
                  <button
                    onClick={() => handleAddCard(CardType.MONSTER)}
                    className="w-full text-center text-sm font-semibold py-2 px-3 rounded-md transition-colors duration-200 bg-purple-600 text-white hover:bg-purple-700"
                    aria-label="Add new monster card"
                  >
                    Add Monster
                  </button>
                  <button
                    onClick={() => handleAddCard(CardType.FORBIDDEN)}
                    className="w-full text-center text-sm font-semibold py-2 px-3 rounded-md transition-colors duration-200 bg-red-600 text-white hover:bg-red-700"
                    aria-label="Add new forbidden card"
                  >
                    Add Forbidden
                  </button>
                </div>
              </div>
              <div>
                <h3 className="text-md font-bold mb-2 text-center sm:text-left">Action Log</h3>
                <div className="bg-white dark:bg-gray-800 rounded-lg p-3 max-h-48 lg:max-h-[calc(100vh-240px)] overflow-y-auto border border-gray-200 dark:border-gray-700 shadow-sm">
                  {actionLog.length === 0 ? (
                    <p className="text-center text-gray-500 dark:text-gray-400 text-sm">No actions yet.</p>
                  ) : (
                    <ul className="space-y-1">
                    {actionLog.slice().reverse().map(log => (
                      <li key={log.id} className="flex justify-between items-center text-sm py-1 border-b border-gray-200 dark:border-gray-700 last:border-b-0">
                        <span>{log.description.charAt(0).toUpperCase() + log.description.slice(1)}</span>
                        <span className={`font-bold font-mono ${log.points > 0 ? 'text-green-500' : log.points < 0 ? 'text-red-500' : 'text-gray-500 dark:text-gray-400'}`}>
                          {log.points > 0 ? `+${log.points}` : log.points}
                        </span>
                      </li>
                    ))}
                    </ul>
                  )}
                </div>
              </div>
            </div>
          </div>
        );
      };

      // --- From App.tsx ---
      const App = () => {
        const [combatantCount, setCombatantCount] = React.useState(1);
        const [tier, setTier] = React.useState(1);
        const [buttonTextSize, setButtonTextSize] = React.useState(12);
        const [theme, setTheme] = React.useState(() => 
          window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'
        );
        const [combatantsHistories, setCombatantsHistories] = React.useState([
          [getInitialGameState()]
        ]);
        const [selectedCombatants, setSelectedCombatants] = React.useState(['default']);
        
        React.useEffect(() => {
          if (theme === 'dark') {
            document.documentElement.classList.add('dark');
          } else {
            document.documentElement.classList.remove('dark');
          }
        }, [theme]);
        
        React.useEffect(() => {
          const diff = combatantCount - combatantsHistories.length;
          if (diff > 0) {
            const newHistories = [...combatantsHistories];
            const newSelections = [...selectedCombatants];
            for (let i = 0; i < diff; i++) {
              newHistories.push([getInitialGameState()]);
              newSelections.push('default');
            }
            setCombatantsHistories(newHistories);
            setSelectedCombatants(newSelections);
          } else if (diff < 0) {
            setCombatantsHistories(current => current.slice(0, combatantCount));
            setSelectedCombatants(current => current.slice(0, combatantCount));
          }
        }, [combatantCount]);
        const scoreLimit = React.useMemo(() => 30 + (tier - 1) * 10, [tier]);
        const handleThemeToggle = () => {
          setTheme(prevTheme => (prevTheme === 'dark' ? 'light' : 'dark'));
        };
        const handleHistoryChange = (index, newHistory) => {
          setCombatantsHistories(currentHistories => {
            const newHistories = [...currentHistories];
            newHistories[index] = newHistory;
            return newHistories;
          });
        };
        const handleCharacterChange = (index, combatantId) => {
          const selectedCombatant = COMBATANTS.find(c => c.id === combatantId);
          if (!selectedCombatant) return;
          setSelectedCombatants(current => {
              const newSelections = [...current];
              newSelections[index] = combatantId;
              return newSelections;
          });
          handleHistoryChange(index, [getInitialGameState(selectedCombatant.deck)]);
        };
        const combatantGridClasses = {
          1: 'grid-cols-1',
          2: 'grid-cols-1 lg:grid-cols-2',
          3: 'grid-cols-1 xl:grid-cols-3',
        };
        return (
          <div className="min-h-screen">
            <div className="sticky top-0 z-10 bg-gray-100/80 dark:bg-gray-900/80 backdrop-blur-sm py-3 mb-4 border-b border-gray-200 dark:border-gray-700">
              <div className="w-full mx-auto px-4 sm:px-6 lg:px-8">
                <div className="flex justify-between items-center gap-4">
                  <div className="flex-1">
                    <h1 className="text-xl font-bold whitespace-nowrap">Save Data Calculator</h1>
                  </div>
                  <div className="flex-1 flex justify-center items-center flex-wrap gap-x-6 gap-y-2">
                    <div className="flex items-center gap-2">
                      <label htmlFor="tier-select" className="font-bold text-sm text-black dark:text-white whitespace-nowrap">Tier</label>
                      <select 
                        id="tier-select"
                        value={tier}
                        onChange={(e) => setTier(parseInt(e.target.value, 10))}
                        className="bg-gray-200 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 text-sm rounded-lg focus:ring-cyan-500 focus:border-cyan-500 block w-16 p-1.5 text-center"
                      >
                        {[...Array(20)].map((_, i) => (
                          <option key={i + 1} value={i + 1}>{i + 1}</option>
                        ))}
                      </select>
                    </div>
                    <div className="flex items-center gap-2">
                      <label htmlFor="combatant-select" className="font-bold text-sm text-black dark:text-white whitespace-nowrap">Combatants</label>
                      <select 
                        id="combatant-select"
                        value={combatantCount}
                        onChange={(e) => setCombatantCount(parseInt(e.target.value, 10))}
                        className="bg-gray-200 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 text-sm rounded-lg focus:ring-cyan-500 focus:border-cyan-500 block w-16 p-1.5 text-center"
                      >
                        {[1, 2, 3].map(i => <option key={i} value={i}>{i}</option>)}
                      </select>
                    </div>
                    <div className="flex items-center gap-2">
                      <label htmlFor="text-size-slider" className="font-bold text-sm text-black dark:text-white whitespace-nowrap">Button Text</label>
                      <input
                        id="text-size-slider"
                        type="range"
                        min="10"
                        max="16"
                        step="0.5"
                        value={buttonTextSize}
                        onChange={(e) => setButtonTextSize(parseFloat(e.target.value))}
                        className="w-24 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700"
                      />
                    </div>
                  </div>
                  <div className="flex-1 flex justify-end items-center gap-2">
                     <a
                      href="https://github.com/asterah/chaos-full-nightmare"
                      target="_blank"
                      rel="noopener noreferrer"
                      className="p-2 bg-gray-200 dark:bg-gray-700 rounded-md transition-colors duration-200 hover:bg-gray-300 dark:hover:bg-gray-600"
                      aria-label="View source on GitHub"
                    >
                      <GitHubIcon className="h-5 w-5" />
                    </a>
                    <button
                      onClick={handleThemeToggle}
                      className="p-2 bg-gray-200 dark:bg-gray-700 rounded-md transition-colors duration-200 hover:bg-gray-300 dark:hover:bg-gray-600"
                      aria-label="Toggle theme"
                    >
                      <ThemeIcon theme={theme} className="h-5 w-5" />
                    </button>
                  </div>
                </div>
              </div>
            </div>
            <main className={`w-full mx-auto px-4 sm:px-6 lg:px-8 pb-8 grid ${combatantGridClasses[combatantCount]} gap-8`}>
              {combatantsHistories.map((history, index) => (
                <CombatantLayout 
                  key={index}
                  combatantIndex={index}
                  history={history}
                  onHistoryChange={(newHistory) => handleHistoryChange(index, newHistory)}
                  scoreLimit={scoreLimit}
                  combatantCount={combatantCount}
                  buttonTextSize={buttonTextSize}
                  combatants={COMBATANTS}
                  selectedCombatantId={selectedCombatants[index]}
                  onCharacterChange={handleCharacterChange}
                />
              ))}
            </main>
          </div>
        );
      };

      // --- From index.tsx ---
      const rootElement = document.getElementById('root');
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }
      const root = ReactDOM.createRoot(rootElement);
      root.render(
        <React.StrictMode>
          <App />
        </React.StrictMode>
      );
    </script>
  <script type="module" src="/index.tsx"></script>
</body>
</html>
