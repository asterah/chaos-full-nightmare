<!DOCTYPE html>
<html lang="en" class="dark">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Save Data Calculator</title>
    <meta name="theme-color" content="#06b6d4" />
    <meta name="description" content="Chaos Zero Night save data tracker." />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        darkMode: 'class',
        theme: {
          extend: {
            fontFamily: {
              sans: ['Inter', 'sans-serif'],
            },
          },
        },
      }
    </script>
    <!-- React, ReactDOM, and Babel for in-browser JSX/TS transformation -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "vite": "https://aistudiocdn.com/vite@^7.2.2",
    "@vitejs/plugin-react": "https://aistudiocdn.com/@vitejs/plugin-react@^5.1.1",
    "vite-plugin-pwa": "https://aistudiocdn.com/vite-plugin-pwa@^1.1.0"
  }
}
</script>
</head>
  <body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-white transition-colors duration-300">
    <div id="root"></div>
    <script src="CardTypes.js"></script>
    <script src="CardDatabase.js"></script>
    <script type="text/babel">
      // --- From constants.ts ---
      const POINTS = {
        NEUTRAL_CARD: 20,
        UNIQUE_CARD: 80,
        MONSTER_CARD: 80,
        FORBIDDEN_CARD: 20,
        EPIPHANY_BONUS: 10,
        DIVINE_EPIPHANY_BONUS: 20,
        CONVERSION_COST: 10,
        BASIC_REMOVAL_BONUS: 20,
      };
      const REMOVAL_COST_LADDER = [0, 10, 30, 50, 70];
      const DUPLICATION_COST_LADDER = [0, 10, 30, 50, 70];

      // --- From state.ts ---
      const getInitialGameState = (initialCards = DEFAULT_DECK) => ({
        cards: JSON.parse(JSON.stringify(initialCards)),
        removedCards: [],
        duplicationCount: 0,
        conversionCount: 0,
        nextId: Math.max(...initialCards.map(c => c.id)) + 1,
        actionLog: [],
        nextLogId: 1,
      });

      // --- From utils.ts ---
      function getLadderCost(ladder, count) {
        const index = Math.min(count, ladder.length - 1);
        return ladder[index];
      }
      const calculateCardScore = (card, initialCardIds) => {
        let score = 0;
        const isNewCard = !initialCardIds.has(card.id);
        const isConvertedToNeutral = card.type === CardType.NEUTRAL && card.originalType !== CardType.NEUTRAL;

        if (isNewCard) {
          if (card.type === CardType.UNIQUE) score += POINTS.UNIQUE_CARD;
          else if (card.type === CardType.MONSTER) score += POINTS.MONSTER_CARD;
          else if (card.type === CardType.NEUTRAL) score += POINTS.NEUTRAL_CARD;
          else if (card.type === CardType.FORBIDDEN) score += POINTS.FORBIDDEN_CARD;
        } else if (isConvertedToNeutral) {
          score += POINTS.NEUTRAL_CARD;
        }

        if (card.type !== CardType.BASIC) {
          if (card.state === CardState.EPIPHANY && card.type !== CardType.UNIQUE) {
            score += POINTS.EPIPHANY_BONUS;
          } else if (card.state === CardState.DIVINE_EPIPHANY) {
            score += POINTS.DIVINE_EPIPHANY_BONUS;
          }
        }
        return score;
      };
      const calculateTotalScore = (state, initialCardIds) => {
        const { cards, removedCards, duplicationCount, conversionCount } = state;
        let score = cards.reduce((total, card) => total + calculateCardScore(card, initialCardIds), 0);
        score += conversionCount * POINTS.CONVERSION_COST;
        let totalDuplicationCost = 0;
        for (let i = 0; i < duplicationCount; i++) {
          totalDuplicationCost += getLadderCost(DUPLICATION_COST_LADDER, i);
        }
        score += totalDuplicationCost;
        let totalRemovalCost = 0;
        removedCards.forEach((card, index) => {
          totalRemovalCost += getLadderCost(REMOVAL_COST_LADDER, index);
          if (card.originalType === CardType.BASIC && card.type === CardType.BASIC) {
            score += POINTS.BASIC_REMOVAL_BONUS;
          }
        });
        score += totalRemovalCost;
        return score;
      };

      // --- From components/Icons.tsx ---
      const PlusIcon = ({ className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
          <path strokeLinecap="round" strokeLinejoin="round" d="M12 4.5v15m7.5-7.5h-15" />
        </svg>
      );
      const UndoIcon = ({ className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}>
          <path fillRule="evenodd" d="M9.53 2.47a.75.75 0 0 1 0 1.06L4.81 8.25H15a6.75 6.75 0 0 1 0 13.5h-3a.75.75 0 0 1 0-1.5h3a5.25 5.25 0 1 0 0-10.5H4.81l4.72 4.72a.75.75 0 1 1-1.06 1.06l-6-6a.75.75 0 0 1 0-1.06l6-6a.75.75 0 0 1 1.06 0Z" clipRule="evenodd" />
        </svg>
      );
      const RedoIcon = ({ className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}>
          <path fillRule="evenodd" d="M14.47 2.47a.75.75 0 0 0 0 1.06L19.19 8.25H9a6.75 6.75 0 0 0 0 13.5h3a.75.75 0 0 0 0-1.5H9a5.25 5.25 0 1 1 0-10.5h10.19l-4.72 4.72a.75.75 0 1 0 1.06 1.06l6-6a.75.75 0 0 0 0-1.06l-6-6a.75.75 0 0 0-1.06 0Z" clipRule="evenodd" />
        </svg>
      );
      const ResetIcon = ({ className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className={className}>
          <path fillRule="evenodd" d="M15.323 4.677a.75.75 0 0 0-1.06-1.06l-1.061 1.06a5.5 5.5 0 1 0 5.484 6.222.75.75 0 1 0-1.488-.223A4 4 0 1 1 13.5 7.018l-1.06 1.06a.75.75 0 0 0 0 1.061.75.75 0 0 0 1.06 0l2.83-2.828a.75.75 0 0 0 0-1.06l-2.83-2.83Z" clipRule="evenodd" />
        </svg>
      );
      const ThemeIcon = ({ theme, className }) => (
        <>
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={`${className} ${theme === 'dark' ? 'block' : 'hidden'}`}>
            <path strokeLinecap="round" strokeLinejoin="round" d="M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-4.773-4.227-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0Z" />
          </svg>
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={`${className} ${theme === 'light' ? 'block' : 'hidden'}`}>
            <path strokeLinecap="round" strokeLinejoin="round" d="M21.752 15.002A9.72 9.72 0 0 1 18 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 0 0 3 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 0 0 9.002-5.998Z" />
          </svg>
        </>
      );
      const EpiphanyIcon = ({ className, style }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className={className} style={style}>
          <path d="M10 7a3 3 0 1 0 0 6 3 3 0 0 0 0-6Z" />
          <path fillRule="evenodd" d="M10 18a8 8 0 1 0 0-16 8 8 0 0 0 0 16Zm0-2a6 6 0 1 0 0-12 6 6 0 0 0 0 12Z" clipRule="evenodd" />
        </svg>
      );
      const DivineEpiphanyIcon = ({ className, style }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className={className} style={style}>
          <path d="m10 0 2.89 7.11 7.11 2.89-7.11 2.89L10 20l-2.89-7.11-7.11-2.89 7.11-2.89L10 0Z" />
        </svg>
      );
      const ArrowPathIcon = ({ className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className={className}>
          <path fillRule="evenodd" d="M15.312 11.424a5.5 5.5 0 0 1-9.201 2.466l-.312-.311h2.433a.75.75 0 0 0 0-1.5H3.989a.75.75 0 0 0-.75.75v4.242a.75.75 0 0 0 1.5 0v-2.43l.31.31a7 7 0 0 0 11.767-3.131.75.75 0 0 0-1.488-.214ZM4.688 8.576a5.5 5.5 0 0 1 9.201-2.466l.312.311H11.76a.75.75 0 0 0 0 1.5h4.243a.75.75 0 0 0 .75-.75V3.029a.75.75 0 0 0-1.5 0v2.43l-.31-.31a7 7 0 0 0-11.767 3.131.75.75 0 0 0 1.488.214Z" clipRule="evenodd" />
        </svg>
      );
      const Square2StackIcon = ({ className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className={className}>
          <path d="M7 3.5A1.5 1.5 0 0 1 8.5 2h6A1.5 1.5 0 0 1 16 3.5v9a1.5 1.5 0 0 1-1.5 1.5h-2.5a.75.75 0 0 1 0-1.5h2.5a.5.5 0 0 0 .5-.5v-9a.5.5 0 0 0-.5-.5h-6a.5.5 0 0 0-.5.5v2.5a.75.75 0 0 1-1.5 0v-2.5Z" />
          <path d="M3.5 6A1.5 1.5 0 0 0 2 7.5v9A1.5 1.5 0 0 0 3.5 18h6a1.5 1.5 0 0 0 1.5-1.5v-9A1.5 1.5 0 0 0 9.5 6h-6Z" />
        </svg>
      );
      const MinusCircleIcon = ({ className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className={className}>
          <path fillRule="evenodd" d="M10 18a8 8 0 1 0 0-16 8 8 0 0 0 0 16ZM6.75 9.25a.75.75 0 0 0 0 1.5h6.5a.75.75 0 0 0 0-1.5h-6.5Z" clipRule="evenodd" />
        </svg>
      );
      const GitHubIcon = ({ className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" className={className} aria-hidden="true">
          <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8Z" />
        </svg>
      );
      const XIcon = ({ className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className={className}>
          <path fillRule="evenodd" d="M10 18a8 8 0 1 0 0-16 8 8 0 0 0 0 16ZM8.28 7.22a.75.75 0 0 0-1.06 1.06L8.94 10l-1.72 1.72a.75.75 0 1 0 1.06 1.06L10 11.06l1.72 1.72a.75.75 0 1 0 1.06-1.06L11.06 10l1.72-1.72a.75.75 0 0 0-1.06-1.06L10 8.94 8.28 7.22Z" clipRule="evenodd" />
        </svg>
      );
      const ChevronDownIcon = ({ className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className={className}>
          <path fillRule="evenodd" d="M5.22 8.22a.75.75 0 0 1 1.06 0L10 11.94l3.72-3.72a.75.75 0 1 1 1.06 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L5.22 9.28a.75.75 0 0 1 0-1.06Z" clipRule="evenodd" />
        </svg>
      );
      const ChevronUpIcon = ({ className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className={className}>
          <path fillRule="evenodd" d="M9.47 7.72a.75.75 0 0 1 1.06 0l4.25 4.25a.75.75 0 1 1-1.06 1.06L10 9.06l-3.72 3.72a.75.75 0 0 1-1.06-1.06l4.25-4.25Z" clipRule="evenodd" />
        </svg>
      );
      const SaveIcon = ({ className }) => (
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className={className}>
          <path d="M3 3.5A1.5 1.5 0 0 1 4.5 2h6.879a1.5 1.5 0 0 1 1.06.44l3.122 3.12A1.5 1.5 0 0 1 16 6.622V16.5a1.5 1.5 0 0 1-1.5 1.5h-10A1.5 1.5 0 0 1 3 16.5v-13Z" />
          <path d="M5.25 2.5a.75.75 0 0 0-.75.75v3.5c0 .414.336.75.75.75h4.5a.75.75 0 0 0 .75-.75v-3.5a.75.75 0 0 0-.75-.75h-4.5Z" />
          <path d="M10.75 12.5a.75.75 0 0 0-.75.75v2.5a.75.75 0 0 0 1.5 0v-2.5a.75.75 0 0 0-.75-.75Z" />
        </svg>
      );
      
      // --- From components/ScoreDisplay.tsx ---
      const LadderIndicator = ({ label, ladder, count }) => {
        const nextCost = count < ladder.length ? ladder[count] : null;
        const getCircleClass = (cost, index) => {
          const isUsed = index < count;
          const baseClass = 'w-3 h-3 rounded-full';
          if (!isUsed) {
            return `${baseClass} border border-gray-400 dark:border-gray-500`;
          }
          if (cost === 0) return `${baseClass} bg-green-500`;
          if (cost <= 10) return `${baseClass} bg-yellow-500`;
          if (cost <= 30) return `${baseClass} bg-orange-500`;
          return `${baseClass} bg-red-500`;
        };
        return (
          <div className="relative group flex items-center gap-2 text-sm font-medium bg-gray-200 dark:bg-gray-700 px-3 py-1.5 rounded-md">
            <span className="text-gray-800 dark:text-gray-300">{label}:</span>
            <div className="flex items-center gap-1">
              {ladder.map((cost, index) => (
                <div key={index} className={getCircleClass(cost, index)} />
              ))}
            </div>
            <div className="absolute bottom-full mb-2 w-max p-2 text-xs text-white bg-gray-900/90 dark:bg-black/90 rounded-md shadow-lg opacity-0 group-hover:opacity-100 pointer-events-none transition-opacity z-10">
              Next Cost: <span className="font-bold">{nextCost !== null ? `${nextCost} points` : 'Max'}</span>
            </div>
          </div>
        );
      };
      const ScoreDisplay = ({ score, scoreLimit, onReset, onUndo, onRedo, isUndoDisabled, isRedoDisabled, isResetDisabled, removalCount, duplicationCount }) => {
        const progressPercentage = Math.min((score / scoreLimit) * 100, 100);
        const isOverLimit = score > scoreLimit;
        return (
          <div className="bg-white dark:bg-gray-800 rounded-lg shadow-md dark:shadow-lg p-4 border border-gray-200 dark:border-gray-700">
            <div className="w-full flex-grow">
              <div className="relative h-8 w-full bg-gray-200 dark:bg-gray-700 rounded-full overflow-hidden border border-gray-300 dark:border-gray-600" role="progressbar" aria-valuenow={score} aria-valuemin="0" aria-valuemax={scoreLimit} aria-label={`Score: ${score} out of ${scoreLimit}`}>
                <div className={`absolute top-0 left-0 h-full rounded-full transition-all duration-300 ${isOverLimit ? 'bg-red-500' : 'bg-cyan-500'}`} style={{ width: `${isOverLimit ? 100 : progressPercentage}%` }}></div>
                <div className="absolute inset-0 flex items-center justify-center" aria-hidden="true">
                  <span className="text-sm font-mono font-bold text-gray-900 dark:text-white tracking-wider">{score} / {scoreLimit}</span>
                </div>
              </div>
            </div>
            <div className="mt-4 flex justify-between items-center">
              <div className="flex items-center gap-3 flex-wrap">
                <LadderIndicator label="Removals" ladder={REMOVAL_COST_LADDER} count={removalCount} />
                <LadderIndicator label="Duplicates" ladder={DUPLICATION_COST_LADDER} count={duplicationCount} />
              </div>
              <div className="flex items-center gap-1.5">
                <button onClick={onUndo} disabled={isUndoDisabled} className="px-2 py-1.5 bg-gray-300 dark:bg-gray-600 text-black dark:text-white font-semibold rounded-md flex items-center gap-1.5 transition-colors duration-200 disabled:opacity-50 hover:enabled:bg-gray-400 dark:hover:enabled:bg-gray-500" aria-label="Undo last action">
                  <UndoIcon className="h-4 w-4" />
                  <span className="hidden sm:inline">Undo</span>
                </button>
                <button onClick={onRedo} disabled={isRedoDisabled} className="px-2 py-1.5 bg-gray-300 dark:bg-gray-600 text-black dark:text-white font-semibold rounded-md flex items-center gap-1.5 transition-colors duration-200 disabled:opacity-50 hover:enabled:bg-gray-400 dark:hover:enabled:bg-gray-500" aria-label="Redo last action">
                  <RedoIcon className="h-4 w-4" />
                  <span className="hidden sm:inline">Redo</span>
                </button>
                <button onClick={onReset} disabled={isResetDisabled} className="px-2 py-1.5 bg-gray-300 dark:bg-gray-600 text-black dark:text-white font-semibold rounded-md flex items-center gap-1.5 transition-colors duration-200 disabled:opacity-50 hover:enabled:bg-gray-400 dark:hover:enabled:bg-gray-500" aria-label="Reset calculator">
                  <ResetIcon className="h-4 w-4" />
                  <span className="hidden sm:inline">Reset</span>
                </button>
              </div>
            </div>
          </div>
        );
      };

      // --- From components/CalculatorCard.tsx ---
      const cardStyles = {
        base: 'aspect-[2/3] w-full max-w-[280px] mx-auto rounded-lg shadow-lg p-3 flex flex-col justify-between transition-all duration-300 border-2 relative',
        [CardType.BASIC]: 'bg-gray-200 border-gray-300 text-gray-800 dark:bg-gray-700 dark:border-gray-600 dark:text-white',
        [CardType.UNIQUE]: 'bg-blue-200 border-blue-400 text-blue-900 dark:bg-blue-900/50 dark:border-blue-700 dark:text-white',
        [CardType.NEUTRAL]: 'bg-stone-300 border-stone-400 text-stone-900 dark:bg-stone-600 dark:border-stone-500 dark:text-white',
        [CardType.MONSTER]: 'bg-gradient-to-br from-purple-400 to-blue-400 border-purple-500 text-white dark:from-purple-800 dark:to-blue-800 dark:border-purple-600',
        [CardType.FORBIDDEN]: 'bg-red-200 border-red-400 text-red-900 dark:bg-red-900/50 dark:border-red-700 dark:text-white',
        ULTIMATE: 'bg-purple-200 border-purple-400 text-purple-900 dark:bg-purple-900/50 dark:border-purple-700 dark:text-white',
      };
      const stateStyles = {
        [CardState.NONE]: 'border-opacity-50',
        [CardState.EPIPHANY]: 'border-yellow-500 dark:border-yellow-400 shadow-yellow-500/40 dark:shadow-yellow-400/30 shadow-[0_0_15px]',
        [CardState.DIVINE_EPIPHANY]: 'border-cyan-500 dark:border-cyan-400 shadow-cyan-500/40 dark:shadow-cyan-400/30 shadow-[0_0_15px]',
      };
      const buttonStyles = {
        base: 'w-full font-semibold py-1.5 rounded-md transition-colors duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-900 flex items-center justify-center gap-1.5',
        enabled: 'hover:bg-opacity-80',
        disabled: 'opacity-50 cursor-not-allowed',
      };
      const ActionButton = ({ onClick, label, color, disabled = false, icon, textSize, className, showLabel }) => (
        <button onClick={onClick} disabled={disabled} style={{ fontSize: `${textSize}px` }} className={`${buttonStyles.base} ${color} ${disabled ? buttonStyles.disabled : buttonStyles.enabled} ${showLabel ? 'px-2' : 'px-1.5'} ${className || ''}`}>
          {icon}
          {showLabel && <span className="min-w-0 truncate">{label}</span>}
        </button>
      );
      const TooltipActionButton = ({ points, onClick, label, color, disabled = false, icon, textSize, className, showLabel }) => {
        if (points === undefined) {
          return <ActionButton onClick={onClick} label={label} color={color} disabled={disabled} icon={icon} textSize={textSize} className={className} showLabel={showLabel} />;
        }
        const pointText = points > 0 ? `+${points}` : `${points}`;
        const pointColor = points > 0 ? 'text-green-400' : points < 0 ? 'text-red-400' : 'text-gray-400';
        return (
          <div className="relative group flex justify-center">
            <ActionButton onClick={onClick} label={label} color={color} disabled={disabled} icon={icon} textSize={textSize} className={className} showLabel={showLabel} />
            {!disabled && (
              <div className="absolute bottom-full mb-2 w-max p-2 text-xs text-white bg-gray-900/90 dark:bg-black/90 rounded-md shadow-lg opacity-0 group-hover:opacity-100 pointer-events-none transition-opacity z-30 transform -translate-x-1/2 left-1/2">
                Points: <span className={`font-bold ${pointColor}`}>{pointText}</span>
              </div>
            )}
          </div>
        );
      };
      const CalculatorCard = ({ card, score, pointPreviews, isLast, onUpdate, onRemove, onDuplicate, onConvert, onDiscard, buttonTextSize }) => {
        const cardRef = React.useRef(null);
        const [isNarrow, setIsNarrow] = React.useState(false);
        React.useEffect(() => {
          const observer = new ResizeObserver(entries => {
            for (const entry of entries) {
              setIsNarrow(entry.contentRect.width < 220);
            }
          });
          const currentRef = cardRef.current;
          if (currentRef) {
            observer.observe(currentRef);
          }
          return () => {
            if (currentRef) {
              observer.unobserve(currentRef);
            }
          };
        }, []);
        const showLabel = !isNarrow;
        const isEpiphanyDisabled = card.type === CardType.BASIC || isLast;
        const isDuplicatable = card.type !== CardType.BASIC && !card.effects?.includes(CardEffect.UNIQUE);
        const isStateLocked = card.state === CardState.EPIPHANY || card.state === CardState.DIVINE_EPIPHANY;
        const handleStateChange = (newState) => {
          if (isStateLocked) {
            return;
          }
          onUpdate({ ...card, state: newState });
        };
        const handleConvert = () => {
          onConvert(card.id);
        };
        const cardTitle = card.name || (isLast ? 'Ultimate' : card.type);
        const hasImage = !!card.imageUrl;
        const backgroundStyle = hasImage ? { backgroundImage: `url(${card.imageUrl})`, backgroundSize: 'cover', backgroundPosition: 'center' } : {};
        const titleColorStylesWithImage = {
          [CardType.BASIC]: 'text-white',
          [CardType.UNIQUE]: 'text-sky-300',
          [CardType.NEUTRAL]: 'text-stone-300',
          [CardType.MONSTER]: 'text-rose-500',
          [CardType.FORBIDDEN]: 'text-red-500',
          ULTIMATE: 'text-fuchsia-400',
        };
        const getTitleClassName = () => {
          if (!hasImage) { return ''; }
          const colorClass = isLast ? titleColorStylesWithImage.ULTIMATE : titleColorStylesWithImage[card.type];
          return `${colorClass}`;
        };
        const actionButtons = [];
        actionButtons.push(
          <TooltipActionButton key="convert" points={pointPreviews.convert} label="Convert" color="bg-gray-300 text-black" onClick={handleConvert} disabled={card.type === CardType.NEUTRAL} icon={<ArrowPathIcon className="w-4 h-4 flex-shrink-0" />} textSize={buttonTextSize} showLabel={showLabel} />
        );
        if (isDuplicatable) {
          actionButtons.push(
            <TooltipActionButton key="duplicate" points={pointPreviews.duplicate} label="Duplicate" color="bg-purple-600 text-white" onClick={() => onDuplicate(card)} icon={<Square2StackIcon className="w-4 h-4 flex-shrink-0" />} textSize={buttonTextSize} showLabel={showLabel} />
          );
        }
        actionButtons.push(
          <TooltipActionButton key="remove" points={pointPreviews.remove} label="Remove" color="bg-red-600 text-white" onClick={() => onRemove(card.id)} icon={<MinusCircleIcon className="w-4 h-4 flex-shrink-0" />} textSize={buttonTextSize} showLabel={showLabel} />
        );
        return (
          <div ref={cardRef} className={`${cardStyles.base} ${isLast ? cardStyles.ULTIMATE : cardStyles[card.type]} ${stateStyles[card.state]}`}>
            <div className={`absolute inset-0 rounded-lg overflow-hidden ${card.isDuplicate ? 'scale-x-[-1]' : ''}`} style={backgroundStyle}>
              {hasImage && (<div className="absolute inset-0 bg-[linear-gradient(to_bottom,rgba(0,0,0,0.8)_0%,transparent_15%,transparent_50%,rgba(0,0,0,0.9)_100%)]"></div>)}
            </div>
            <div className="relative z-10 flex flex-col justify-between h-full">
              <div className="absolute top-2 left-2 z-20 flex flex-col items-center gap-1.5">
                {score > 0 && (<div className="bg-gray-900/70 text-white font-bold text-xs rounded-full h-6 w-6 flex items-center justify-center border-2 border-white/50">{score}</div>)}
                {card.state === CardState.EPIPHANY && <EpiphanyIcon className="w-6 h-6 text-yellow-400" style={{ filter: 'drop-shadow(0 1px 2px rgb(0 0 0 / 0.5))' }} />}
                {card.state === CardState.DIVINE_EPIPHANY && <DivineEpiphanyIcon className="w-6 h-6 text-cyan-400" style={{ filter: 'drop-shadow(0 1px 2px rgb(0 0 0 / 0.5))' }} />}
              </div>
              {card.type === CardType.NEUTRAL && (
                <div className="group absolute top-2 right-2 z-20">
                  <button onClick={() => onDiscard(card.id)} className="p-0.5 bg-gray-600/50 hover:bg-red-600 rounded-full text-white transition-colors" aria-label="Discard Neutral Card">
                    <XIcon className="w-4 h-4" />
                  </button>
                  <div className="absolute right-full top-1/2 -translate-y-1/2 mr-2 w-max max-w-xs p-2 text-xs text-white bg-gray-900/90 dark:bg-black/90 rounded-md shadow-lg opacity-0 group-hover:opacity-100 pointer-events-none">Only click this if Neutral card has [Remove] effect</div>
                </div>
              )}
              <div className="text-center min-h-[3rem] mt-2">
                {showLabel && (<p className={`font-bold text-sm sm:text-base ${getTitleClassName()}`}>{cardTitle}</p>)}
              </div>
              <div className="flex-grow my-2 flex items-center justify-center min-h-0"></div>
              <div className="flex flex-col gap-1.5">
                {!isEpiphanyDisabled && (
                  <div className="grid grid-cols-2 gap-1.5">
                    <TooltipActionButton points={pointPreviews.epiphany} label="Epiphany" color="bg-yellow-500 text-black" onClick={() => handleStateChange(CardState.EPIPHANY)} icon={<EpiphanyIcon className="w-4 h-4 flex-shrink-0" />} textSize={buttonTextSize} disabled={isStateLocked} showLabel={showLabel} />
                    <TooltipActionButton points={pointPreviews.divine} label="Divine" color="bg-cyan-500 text-black" onClick={() => handleStateChange(CardState.DIVINE_EPIPHANY)} icon={<DivineEpiphanyIcon className="w-4 h-4 flex-shrink-0" />} textSize={buttonTextSize} disabled={isStateLocked} showLabel={showLabel} />
                  </div>
                )}
                <div className="grid grid-cols-2 gap-1.5">
                  {actionButtons.map((button, index) => {
                    if (actionButtons.length % 2 !== 0 && index === actionButtons.length - 1) {
                      return <div key={button.key} className="col-span-2">{button}</div>;
                    }
                    return button;
                  })}
                </div>
              </div>
            </div>
          </div>
        );
      };

      // --- From components/CombatantLayout.tsx ---
      const CombatantLayout = ({ combatantIndex, historyState, onHistoryChange, scoreLimit, buttonTextSize, combatants, selectedCombatantId, onCharacterChange, totalCombatants }) => {
        const { history, currentIndex } = historyState;
        const currentGameState = history[currentIndex];
        const { cards, removedCards, duplicationCount, actionLog } = currentGameState;
        const [isLogExpanded, setIsLogExpanded] = React.useState(false);
        const lastLog = actionLog.length > 0 ? actionLog[actionLog.length - 1] : null;
        const initialCardIds = React.useMemo(() => new Set(history[0].cards.map(c => c.id)), [history[0]]);
        const handleReset = () => {
          const selectedCombatant = combatants.find(c => c.id === selectedCombatantId);
          onHistoryChange({ history: [getInitialGameState(selectedCombatant?.deck)], currentIndex: 0 });
        };
        const handleUndo = () => {
          if (currentIndex > 0) {
            onHistoryChange({ ...historyState, currentIndex: currentIndex - 1 });
          }
        };
        const handleRedo = () => {
          if (currentIndex < history.length - 1) {
            onHistoryChange({ ...historyState, currentIndex: currentIndex + 1 });
          }
        };
        const updateGameStateAndLog = (updater, description, overridePoints) => {
          const validHistory = history.slice(0, currentIndex + 1);
          const oldState = validHistory[validHistory.length - 1];
          const oldScore = calculateTotalScore(oldState, initialCardIds);
          const changes = updater(oldState);
          const tempNewState = { ...oldState, ...changes };
          const newScore = calculateTotalScore(tempNewState, initialCardIds);
          const pointChange = overridePoints !== undefined ? overridePoints : newScore - oldScore;
          const newLogEntry = { id: oldState.nextLogId, description: description, points: pointChange };
          const finalState = { ...tempNewState, actionLog: [...oldState.actionLog, newLogEntry], nextLogId: oldState.nextLogId + 1 };
          const newFullHistory = [...validHistory, finalState];
          onHistoryChange({ history: newFullHistory, currentIndex: newFullHistory.length - 1 });
        };
        const capitalize = (s) => s.charAt(0).toUpperCase() + s.slice(1);
        const formatStateName = (s) => s.replace(/_/g, ' ').split(' ').map(capitalize).join(' ');
        const getCardBaseName = (card) => {
          if (card.name) return card.name;
          return `${card.isUltimate ? 'Ultimate' : capitalize(card.type)} Card`;
        };
        const formatCardName = (card) => {
            const baseName = getCardBaseName(card);
            if (card.state !== CardState.NONE) {
                return `${formatStateName(card.state)} ${baseName}`;
            }
            return baseName;
        };
        const handleAddCard = (type) => {
          const updater = (current) => {
            const newCard = { id: current.nextId, type: type, originalType: type, state: CardState.NONE, name: `${capitalize(type)} Card` };
            return { cards: [...current.cards, newCard], nextId: current.nextId + 1 };
          };
          updateGameStateAndLog(updater, `add ${capitalize(type)} Card`);
        };
        const handleUpdateCard = (updatedCard) => {
          const oldCard = currentGameState.cards.find(c => c.id === updatedCard.id);
          if (!oldCard) return;
          const updater = (current) => ({ cards: current.cards.map(card => (card.id === updatedCard.id ? updatedCard : card)) });
          let description = `update ${formatCardName(oldCard)}`;
          if (oldCard.state !== updatedCard.state) {
              const cardBaseName = getCardBaseName(oldCard);
              if (updatedCard.state === CardState.NONE) {
                  description = `remove ${formatStateName(oldCard.state)} from ${cardBaseName}`;
              } else if (oldCard.state === CardState.NONE) {
                  description = `${formatStateName(updatedCard.state)} to ${cardBaseName}`;
              } else {
                  description = `convert ${cardBaseName} to ${formatStateName(updatedCard.state)}`;
              }
          }
          updateGameStateAndLog(updater, description);
        };
        const handleConvertCard = (cardId) => {
          const cardToConvert = currentGameState.cards.find(c => c.id === cardId);
          if (!cardToConvert) return;
          const updater = (current) => {
            const newNeutralCard = {
              id: cardToConvert.id,
              type: CardType.NEUTRAL,
              originalType: cardToConvert.originalType,
              state: CardState.NONE,
              name: 'Neutral Card',
              effects: [],
              isUltimate: false,
              isDuplicate: false,
              imageUrl: generateDummyImage('Neutral Card', cardImageColors[CardType.NEUTRAL]),
            };
            return {
              cards: current.cards.map(card => card.id === cardId ? newNeutralCard : card),
              conversionCount: current.conversionCount + 1,
            };
          };
          updateGameStateAndLog(updater, `convert ${formatCardName(cardToConvert)} to Neutral`);
        };
        const handleRemoveCard = (cardId) => {
          const cardToRemove = currentGameState.cards.find(card => card.id === cardId);
          if (!cardToRemove) return;
          const updater = (current) => ({
            cards: current.cards.filter(card => card.id !== cardId),
            removedCards: [...current.removedCards, cardToRemove],
          });
          updateGameStateAndLog(updater, `remove ${formatCardName(cardToRemove)}`);
        };
        const handleDiscardCard = (cardId) => {
          const cardToDiscard = currentGameState.cards.find(c => c.id === cardId);
          if (!cardToDiscard || cardToDiscard.type !== CardType.NEUTRAL) return;
          const updater = (current) => ({ cards: current.cards.filter(card => card.id !== cardId) });
          updateGameStateAndLog(updater, 'remove Neutral Card by [Remove] effect', 0);
        };
        const handleDuplicateCard = (cardToDuplicate) => {
          const updater = (current) => {
            const newCard = { ...cardToDuplicate, id: current.nextId, state: cardToDuplicate.state, isUltimate: false, isDuplicate: true };
            return { cards: [...current.cards, newCard], duplicationCount: current.duplicationCount + 1, nextId: current.nextId + 1 };
          };
          updateGameStateAndLog(updater, `duplicate ${formatCardName(cardToDuplicate)}`);
        };
        const totalScore = React.useMemo(() => calculateTotalScore(currentGameState, initialCardIds), [currentGameState, initialCardIds]);
        const pointPreviews = React.useMemo(() => {
          const previews = {};
          if (!currentGameState) return {};
          const calculateScoreChange = (updater) => {
              const tempState = { ...currentGameState, ...updater(currentGameState) };
              const newScore = calculateTotalScore(tempState, initialCardIds);
              return newScore - totalScore;
          };
          currentGameState.cards.forEach(card => {
              previews[card.id] = {};
              if (card.state === CardState.NONE && card.type !== CardType.BASIC && !card.isUltimate) {
                  previews[card.id].epiphany = calculateScoreChange(c => ({ cards: c.cards.map(c => c.id === card.id ? { ...c, state: CardState.EPIPHANY } : c) }));
                  previews[card.id].divine = calculateScoreChange(c => ({ cards: c.cards.map(c => c.id === card.id ? { ...c, state: CardState.DIVINE_EPIPHANY } : c) }));
              }
              if (card.type !== CardType.NEUTRAL) {
                  previews[card.id].convert = calculateScoreChange(c => ({ cards: c.cards.map(c => c.id !== card.id ? c : { id: card.id, type: CardType.NEUTRAL, originalType: card.originalType, state: CardState.NONE, name: 'Neutral Card', effects: [], isUltimate: false, isDuplicate: false, imageUrl: generateDummyImage('Neutral Card', cardImageColors[CardType.NEUTRAL]) }), conversionCount: c.conversionCount + 1 }));
              }
              const isDuplicatable = card.type !== CardType.BASIC && !card.effects?.includes(CardEffect.UNIQUE);
              if (isDuplicatable) {
                  previews[card.id].duplicate = calculateScoreChange(c => ({ cards: [...c.cards, { ...card, id: c.nextId, state: card.state, isDuplicate: true }], duplicationCount: c.duplicationCount + 1, nextId: c.nextId + 1 }));
              }
              previews[card.id].remove = calculateScoreChange(c => ({ cards: c.cards.filter(c => c.id !== card.id), removedCards: [...c.removedCards, card] }));
          });
          return previews;
        }, [currentGameState, totalScore, initialCardIds]);
        const combatantGridClasses = {
          1: 'grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6',
          2: 'grid-cols-2 sm:grid-cols-3 md:grid-cols-4',
          3: 'grid-cols-4',
        }[totalCombatants] || 'grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6';
        return (
          <div className="flex flex-col gap-4 bg-gray-100 dark:bg-gray-900/50 p-4 rounded-xl border border-gray-200 dark:border-gray-700">
            <div className="flex items-center justify-center gap-2">
              <select id={`combatant-character-select-${combatantIndex}`} value={selectedCombatantId} onChange={(e) => onCharacterChange(combatantIndex, e.target.value)} className="bg-gray-200 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 text-lg font-bold rounded-lg focus:ring-cyan-500 focus:border-cyan-500 block w-auto p-1.5">
                {combatants.map(c => (<option key={c.id} value={c.id}>{c.name}</option>))}
              </select>
            </div>
            <ScoreDisplay score={totalScore} scoreLimit={scoreLimit} onReset={handleReset} onUndo={handleUndo} onRedo={handleRedo} isUndoDisabled={currentIndex === 0} isRedoDisabled={currentIndex >= history.length - 1} isResetDisabled={history.length === 1 && currentIndex === 0} removalCount={removedCards.length} duplicationCount={duplicationCount} />
            <div className={totalCombatants === 1 ? "lg:grid lg:grid-cols-[minmax(0,_2fr)_minmax(0,_1fr)] gap-4" : "contents"}>
              <div className={`grid ${combatantGridClasses} gap-4`}>
                {cards.map((card) => (
                  <CalculatorCard key={card.id} card={card} score={calculateCardScore(card, initialCardIds)} pointPreviews={pointPreviews[card.id] || {}} isLast={!!card.isUltimate} onUpdate={handleUpdateCard} onRemove={handleRemoveCard} onDuplicate={handleDuplicateCard} onConvert={handleConvertCard} onDiscard={handleDiscardCard} buttonTextSize={buttonTextSize} />
                ))}
                <div className="aspect-[2/3] w-full max-w-[280px] mx-auto rounded-lg border-2 border-dashed border-gray-400 dark:border-gray-600 flex flex-col items-center justify-center p-3 gap-2">
                  <button onClick={() => handleAddCard(CardType.NEUTRAL)} className="w-full text-center text-sm font-semibold py-2 px-3 rounded-md transition-colors duration-200 bg-stone-500 text-white hover:bg-stone-600 dark:bg-stone-600 dark:hover:bg-stone-500" aria-label="Add new neutral card">Add Neutral</button>
                  <button onClick={() => handleAddCard(CardType.MONSTER)} className="w-full text-center text-sm font-semibold py-2 px-3 rounded-md transition-colors duration-200 bg-purple-600 text-white hover:bg-purple-700" aria-label="Add new monster card">Add Monster</button>
                  <button onClick={() => handleAddCard(CardType.FORBIDDEN)} className="w-full text-center text-sm font-semibold py-2 px-3 rounded-md transition-colors duration-200 bg-red-600 text-white hover:bg-red-700" aria-label="Add new forbidden card">Add Forbidden</button>
                </div>
              </div>
              <div>
                <div className="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700">
                  <button onClick={() => setIsLogExpanded(!isLogExpanded)} className="w-full flex justify-between items-center p-3 text-left disabled:cursor-not-allowed" disabled={actionLog.length === 0} aria-expanded={isLogExpanded} aria-controls={`action-log-content-${combatantIndex}`}>
                    <h3 className="text-md font-bold">{isLogExpanded ? 'Action Log' : (lastLog ? 'Last Action' : 'Action Log')}</h3>
                    {actionLog.length > 0 && (isLogExpanded ? <ChevronUpIcon className="w-5 h-5" /> : <ChevronDownIcon className="w-5 h-5" />)}
                  </button>
                  <div className={`transition-all duration-300 ease-in-out overflow-hidden ${isLogExpanded ? 'max-h-[calc(100vh-280px)]' : 'max-h-0'}`} id={`action-log-content-${combatantIndex}`}>
                    <div className="border-t border-gray-200 dark:border-gray-700">
                      <div className="p-3 max-h-48 lg:max-h-[calc(100vh-320px)] overflow-y-auto">
                        <ul className="space-y-1">
                          {actionLog.slice().reverse().map(log => (
                            <li key={log.id} className="flex justify-between items-center text-sm py-1 border-b border-gray-200 dark:border-gray-700 last:border-b-0">
                              <span>{log.description.charAt(0).toUpperCase() + log.description.slice(1)}</span>
                              <span className={`font-bold font-mono ${log.points > 0 ? 'text-green-500' : log.points < 0 ? 'text-red-500' : 'text-gray-500 dark:text-gray-400'}`}>{log.points > 0 ? `+${log.points}` : log.points}</span>
                            </li>
                          ))}
                        </ul>
                      </div>
                    </div>
                  </div>
                  {!isLogExpanded && (
                    <div className={`p-3 ${actionLog.length > 0 ? 'border-t border-gray-200 dark:border-gray-700' : ''}`}>
                      {lastLog ? (
                        <div className="flex justify-between items-center text-sm">
                          <span>{lastLog.description.charAt(0).toUpperCase() + lastLog.description.slice(1)}</span>
                          <span className={`font-bold font-mono ${lastLog.points > 0 ? 'text-green-500' : lastLog.points < 0 ? 'text-red-500' : 'text-gray-500 dark:text-gray-400'}`}>{lastLog.points > 0 ? `+${lastLog.points}` : lastLog.points}</span>
                        </div>
                      ) : (<p className="text-center text-gray-500 dark:text-gray-400 text-sm">No actions yet.</p>)}
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>
        );
      };

      // --- From App.tsx ---
      const App = () => {
        const [combatantCount, setCombatantCount] = React.useState(1);
        const [tier, setTier] = React.useState(1);
        const [buttonTextSize, setButtonTextSize] = React.useState(12);
        const [theme, setTheme] = React.useState(() => window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
        const [combatantsHistories, setCombatantsHistories] = React.useState([{ history: [getInitialGameState()], currentIndex: 0 }]);
        const [selectedCombatants, setSelectedCombatants] = React.useState(['default']);
        const [presets, setPresets] = React.useState([]);

        React.useEffect(() => {
          try {
            const savedPresets = localStorage.getItem('combatantPresets');
            if (savedPresets) { setPresets(JSON.parse(savedPresets)); }
          } catch (error) {
            console.error("Failed to load presets:", error);
            localStorage.removeItem('combatantPresets');
          }
        }, []);

        React.useEffect(() => {
          try {
            localStorage.setItem('combatantPresets', JSON.stringify(presets));
          } catch (error) {
            console.error("Failed to save presets:", error);
          }
        }, [presets]);
        
        React.useEffect(() => {
          document.documentElement.classList.toggle('dark', theme === 'dark');
        }, [theme]);
        
        React.useEffect(() => {
          const diff = combatantCount - combatantsHistories.length;
          if (diff > 0) {
            const newHistories = [...combatantsHistories];
            const newSelections = [...selectedCombatants];
            for (let i = 0; i < diff; i++) {
              newHistories.push({ history: [getInitialGameState()], currentIndex: 0 });
              newSelections.push('default');
            }
            setCombatantsHistories(newHistories);
            setSelectedCombatants(newSelections);
          } else if (diff < 0) {
            setCombatantsHistories(current => current.slice(0, combatantCount));
            setSelectedCombatants(current => current.slice(0, combatantCount));
          }
        }, [combatantCount]);

        const scoreLimit = React.useMemo(() => 30 + (tier - 1) * 10, [tier]);
        
        const handleThemeToggle = () => setTheme(prev => (prev === 'dark' ? 'light' : 'dark'));

        const handleHistoryChange = (index, newHistoryState) => {
          setCombatantsHistories(current => {
            const newHistories = [...current];
            newHistories[index] = newHistoryState;
            return newHistories;
          });
        };

        const handleCharacterChange = (index, combatantId) => {
          const selectedCombatant = COMBATANTS.find(c => c.id === combatantId);
          if (!selectedCombatant) return;
          setSelectedCombatants(current => {
              const newSelections = [...current];
              newSelections[index] = combatantId;
              return newSelections;
          });
          handleHistoryChange(index, { history: [getInitialGameState(selectedCombatant.deck)], currentIndex: 0 });
        };

        const handleSavePreset = () => {
          if (combatantCount !== 3) return;
          const name = prompt("Enter a name for this team preset:");
          if (!name || name.trim() === '') {
            alert("Preset name cannot be empty.");
            return;
          }
          if (presets.some(p => p.name === name)) {
            alert(`A preset with the name "${name}" already exists.`);
            return;
          }
          const newPreset = { name, combatantIds: selectedCombatants };
          setPresets(prev => [...prev, newPreset].sort((a, b) => a.name.localeCompare(b.name)));
        };

        const handleLoadPreset = (presetName) => {
          if (presetName === 'none') return;
          const preset = presets.find(p => p.name === presetName);
          if (!preset) return;
          const newCombatantCount = preset.combatantIds.length;
          const newSelectedCombatants = preset.combatantIds;
          const newHistories = newSelectedCombatants.map(id => ({ history: [getInitialGameState(COMBATANTS.find(c => c.id === id)?.deck)], currentIndex: 0 }));
          setCombatantCount(newCombatantCount);
          setSelectedCombatants(newSelectedCombatants);
          setCombatantsHistories(newHistories);
        };

        const handleDeletePreset = () => {
          if (presets.length === 0) return;
          const presetNames = presets.map(p => p.name).join('\n - ');
          const nameToDelete = prompt(`Enter the name of the preset to delete:\n\nAvailable presets:\n - ${presetNames}`);
          if (!nameToDelete || !presets.some(p => p.name === nameToDelete)) {
            if (nameToDelete) alert(`Preset "${nameToDelete}" not found.`);
            return;
          }
          if (confirm(`Are you sure you want to delete the preset "${nameToDelete}"?`)) {
            setPresets(prev => prev.filter(p => p.name !== nameToDelete));
          }
        };

        const combatantGridClasses = { 1: 'grid-cols-1', 2: 'grid-cols-1 lg:grid-cols-2', 3: 'grid-cols-1 xl:grid-cols-3' };

        return (
          <div className="min-h-screen">
            <div className="sticky top-0 z-10 bg-gray-100/80 dark:bg-gray-900/80 backdrop-blur-sm py-3 mb-4 border-b border-gray-200 dark:border-gray-700">
              <div className="w-full mx-auto px-4 sm:px-6 lg:px-8">
                <div className="flex justify-between items-center gap-4">
                  <div className="flex-1">
                    <h1 className="text-xl font-bold whitespace-nowrap">Save Data Tracker</h1>
                  </div>
                  <div className="flex-1 flex justify-center items-center flex-wrap gap-x-6 gap-y-2">
                    <div className="flex items-center gap-2">
                      <label htmlFor="tier-select" className="font-bold text-sm text-black dark:text-white whitespace-nowrap">Tier</label>
                      <select id="tier-select" value={tier} onChange={(e) => setTier(parseInt(e.target.value, 10))} className="bg-gray-200 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 text-sm rounded-lg focus:ring-cyan-500 focus:border-cyan-500 block w-16 p-1.5 text-center">
                        {[...Array(20)].map((_, i) => (<option key={i + 1} value={i + 1}>{i + 1}</option>))}
                      </select>
                    </div>
                    <div className="flex items-center gap-2">
                      <label htmlFor="combatant-select" className="font-bold text-sm text-black dark:text-white whitespace-nowrap">Combatants</label>
                      <select id="combatant-select" value={combatantCount} onChange={(e) => setCombatantCount(parseInt(e.target.value, 10))} className="bg-gray-200 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 text-sm rounded-lg focus:ring-cyan-500 focus:border-cyan-500 block w-16 p-1.5 text-center">
                        {[1, 2, 3].map(i => <option key={i} value={i}>{i}</option>)}
                      </select>
                    </div>
                    <div className="flex items-center gap-1.5">
                      <select id="preset-select" value="none" onChange={(e) => { handleLoadPreset(e.target.value); e.target.value = 'none'; }} className="bg-gray-200 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 text-sm rounded-lg focus:ring-cyan-500 focus:border-cyan-500 block w-auto p-1.5 pr-8" aria-label="Load team preset">
                        <option value="none" disabled>W.I.P.</option>
                        {presets.map(p => <option key={p.name} value={p.name}>{p.name}</option>)}
                      </select>
                      <div className="relative group">
                        <button onClick={handleSavePreset} disabled={combatantCount !== 3} className="p-2 bg-gray-200 dark:bg-gray-700 rounded-md transition-colors duration-200 hover:enabled:bg-gray-300 dark:hover:enabled:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed" aria-label="Save current team">
                          <SaveIcon className="h-5 w-5" />
                        </button>
                        {combatantCount !== 3 && (<div className="absolute top-full mt-2 -translate-x-1/2 left-1/2 w-max p-2 text-xs text-white bg-gray-900/90 dark:bg-black/90 rounded-md shadow-lg opacity-0 group-hover:opacity-100 pointer-events-none z-20">Can only save teams of 3.</div>)}
                      </div>
                      <button onClick={handleDeletePreset} disabled={presets.length === 0} className="p-2 bg-gray-200 dark:bg-gray-700 rounded-md transition-colors duration-200 hover:enabled:bg-gray-300 dark:hover:enabled:bg-gray-600 disabled:opacity-50" aria-label="Delete a team preset"><XIcon className="h-5 w-5" /></button>
                    </div>
                    <div className="flex items-center gap-2">
                      <label htmlFor="text-size-slider" className="font-bold text-sm text-black dark:text-white whitespace-nowrap">Button Text</label>
                      <input id="text-size-slider" type="range" min="10" max="16" step="0.5" value={buttonTextSize} onChange={(e) => setButtonTextSize(parseFloat(e.target.value))} className="w-24 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700" />
                    </div>
                  </div>
                  <div className="flex-1 flex justify-end items-center gap-2">
                    <a href="https://github.com/asterah/chaos-full-nightmare" target="_blank" rel="noopener noreferrer" className="p-2 bg-gray-200 dark:bg-gray-700 rounded-md transition-colors duration-200 hover:bg-gray-300 dark:hover:bg-gray-600" aria-label="View source on GitHub"><GitHubIcon className="h-5 w-5" /></a>
                    <button onClick={handleThemeToggle} className="p-2 bg-gray-200 dark:bg-gray-700 rounded-md transition-colors duration-200 hover:bg-gray-300 dark:hover:bg-gray-600" aria-label="Toggle theme"><ThemeIcon theme={theme} className="h-5 w-5" /></button>
                  </div>
                </div>
              </div>
            </div>
            <main className={`w-full mx-auto px-4 sm:px-6 lg:px-8 pb-8 grid ${combatantGridClasses[combatantCount]} gap-8`}>
              {combatantsHistories.map((historyState, index) => (
                <CombatantLayout key={index} combatantIndex={index} historyState={historyState} onHistoryChange={(newHistory) => handleHistoryChange(index, newHistory)} scoreLimit={scoreLimit} buttonTextSize={buttonTextSize} combatants={COMBATANTS} selectedCombatantId={selectedCombatants[index]} onCharacterChange={handleCharacterChange} totalCombatants={combatantCount} />
              ))}
            </main>
          </div>
        );
      };

      // --- From index.tsx ---
      const rootElement = document.getElementById('root');
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }
      const root = ReactDOM.createRoot(rootElement);
      root.render(
        <React.StrictMode>
          <App />
        </React.StrictMode>
      );
    </script>
</body>
</html>